import { Vector3, EventDispatcher, Spherical, MathUtils } from "three";
const targetPosition = new Vector3();
class FirstPersonControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.enabled = true;
    this.movementSpeed = 1;
    this.lookSpeed = 5e-3;
    this.lookVertical = true;
    this.autoForward = false;
    this.activeLook = true;
    this.heightSpeed = false;
    this.heightCoef = 1;
    this.heightMin = 0;
    this.heightMax = 1;
    this.constrainVertical = false;
    this.verticalMin = 0;
    this.verticalMax = Math.PI;
    this.mouseDragOn = false;
    this.autoSpeedFactor = 0;
    this.mouseX = 0;
    this.mouseY = 0;
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.moveUp = false;
    this.moveDown = false;
    this.viewHalfX = 0;
    this.viewHalfY = 0;
    this.lat = 0;
    this.lon = 0;
    this.lookDirection = new Vector3();
    this.spherical = new Spherical();
    this.target = new Vector3();
    this.connect = (domElement2) => {
      domElement2.setAttribute("tabindex", "-1");
      domElement2.style.touchAction = "none";
      domElement2.addEventListener("contextmenu", this.contextmenu);
      domElement2.addEventListener("mousemove", this.onMouseMove);
      domElement2.addEventListener("mousedown", this.onMouseDown);
      domElement2.addEventListener("mouseup", this.onMouseUp);
      this.domElement = domElement2;
      window.addEventListener("keydown", this.onKeyDown);
      window.addEventListener("keyup", this.onKeyUp);
      this.handleResize();
    };
    this.dispose = () => {
      var _a, _b, _c, _d;
      (_a = this.domElement) == null ? void 0 : _a.removeEventListener("contextmenu", this.contextmenu);
      (_b = this.domElement) == null ? void 0 : _b.removeEventListener("mousedown", this.onMouseDown);
      (_c = this.domElement) == null ? void 0 : _c.removeEventListener("mousemove", this.onMouseMove);
      (_d = this.domElement) == null ? void 0 : _d.removeEventListener("mouseup", this.onMouseUp);
      window.removeEventListener("keydown", this.onKeyDown);
      window.removeEventListener("keyup", this.onKeyUp);
    };
    this.handleResize = () => {
      if (this.domElement) {
        this.viewHalfX = this.domElement.offsetWidth / 2;
        this.viewHalfY = this.domElement.offsetHeight / 2;
      }
    };
    this.onMouseDown = (event) => {
      var _a;
      (_a = this.domElement) == null ? void 0 : _a.focus();
      if (this.activeLook) {
        switch (event.button) {
          case 0:
            this.moveForward = true;
            break;
          case 2:
            this.moveBackward = true;
            break;
        }
      }
      this.mouseDragOn = true;
    };
    this.onMouseUp = (event) => {
      if (this.activeLook) {
        switch (event.button) {
          case 0:
            this.moveForward = false;
            break;
          case 2:
            this.moveBackward = false;
            break;
        }
      }
      this.mouseDragOn = false;
    };
    this.onMouseMove = (event) => {
      if (this.domElement) {
        this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
        this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
      }
    };
    this.onKeyDown = (event) => {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = true;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = true;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = true;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = true;
          break;
        case "KeyR":
          this.moveUp = true;
          break;
        case "KeyF":
          this.moveDown = true;
          break;
      }
    };
    this.onKeyUp = (event) => {
      switch (event.code) {
        case "ArrowUp":
        case "KeyW":
          this.moveForward = false;
          break;
        case "ArrowLeft":
        case "KeyA":
          this.moveLeft = false;
          break;
        case "ArrowDown":
        case "KeyS":
          this.moveBackward = false;
          break;
        case "ArrowRight":
        case "KeyD":
          this.moveRight = false;
          break;
        case "KeyR":
          this.moveUp = false;
          break;
        case "KeyF":
          this.moveDown = false;
          break;
      }
    };
    this.lookAt = (x, y, z) => {
      if (x instanceof Vector3) {
        this.target.copy(x);
      } else if (y && z) {
        this.target.set(x, y, z);
      }
      this.object.lookAt(this.target);
      this.setOrientation();
      return this;
    };
    this.update = (delta) => {
      if (!this.enabled)
        return;
      if (this.heightSpeed) {
        const y = MathUtils.clamp(this.object.position.y, this.heightMin, this.heightMax);
        const heightDelta = y - this.heightMin;
        this.autoSpeedFactor = delta * (heightDelta * this.heightCoef);
      } else {
        this.autoSpeedFactor = 0;
      }
      const actualMoveSpeed = delta * this.movementSpeed;
      if (this.moveForward || this.autoForward && !this.moveBackward) {
        this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));
      }
      if (this.moveBackward)
        this.object.translateZ(actualMoveSpeed);
      if (this.moveLeft)
        this.object.translateX(-actualMoveSpeed);
      if (this.moveRight)
        this.object.translateX(actualMoveSpeed);
      if (this.moveUp)
        this.object.translateY(actualMoveSpeed);
      if (this.moveDown)
        this.object.translateY(-actualMoveSpeed);
      let actualLookSpeed = delta * this.lookSpeed;
      if (!this.activeLook) {
        actualLookSpeed = 0;
      }
      let verticalLookRatio = 1;
      if (this.constrainVertical) {
        verticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);
      }
      this.lon -= this.mouseX * actualLookSpeed;
      if (this.lookVertical)
        this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;
      this.lat = Math.max(-85, Math.min(85, this.lat));
      let phi = MathUtils.degToRad(90 - this.lat);
      const theta = MathUtils.degToRad(this.lon);
      if (this.constrainVertical) {
        phi = MathUtils.mapLinear(phi, 0, Math.PI, this.verticalMin, this.verticalMax);
      }
      const position = this.object.position;
      targetPosition.setFromSphericalCoords(1, phi, theta).add(position);
      this.object.lookAt(targetPosition);
    };
    this.contextmenu = (event) => event.preventDefault();
    this.setOrientation = () => {
      this.lookDirection.set(0, 0, -1).applyQuaternion(this.object.quaternion);
      this.spherical.setFromVector3(this.lookDirection);
      this.lat = 90 - MathUtils.radToDeg(this.spherical.phi);
      this.lon = MathUtils.radToDeg(this.spherical.theta);
    };
    this.object = object;
    this.domElement = domElement;
    this.setOrientation();
    if (domElement)
      this.connect(domElement);
  }
}
export {
  FirstPersonControls
};
