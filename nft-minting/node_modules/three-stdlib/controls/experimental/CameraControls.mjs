import { EventDispatcher, Vector3, TOUCH, Spherical, Vector2, Quaternion, PerspectiveCamera, OrthographicCamera, MOUSE } from "three";
var STATE = /* @__PURE__ */ ((STATE2) => {
  STATE2[STATE2["NONE"] = -1] = "NONE";
  STATE2[STATE2["ROTATE"] = 0] = "ROTATE";
  STATE2[STATE2["DOLLY"] = 1] = "DOLLY";
  STATE2[STATE2["PAN"] = 2] = "PAN";
  STATE2[STATE2["TOUCH_ROTATE"] = 3] = "TOUCH_ROTATE";
  STATE2[STATE2["TOUCH_PAN"] = 4] = "TOUCH_PAN";
  STATE2[STATE2["TOUCH_DOLLY_PAN"] = 5] = "TOUCH_DOLLY_PAN";
  STATE2[STATE2["TOUCH_DOLLY_ROTATE"] = 6] = "TOUCH_DOLLY_ROTATE";
  return STATE2;
})(STATE || {});
class CameraControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.enabled = true;
    this.target = new Vector3();
    this.trackball = false;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = false;
    this.keyPanSpeed = 7;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.enableKeys = true;
    this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.spherical = new Spherical();
    this.sphericalDelta = new Spherical();
    this.changeEvent = { type: "change" };
    this.startEvent = { type: "start" };
    this.endEvent = { type: "end" };
    this.state = -1;
    this.EPS = 1e-6;
    this.scale = 1;
    this.panOffset = new Vector3();
    this.zoomChanged = false;
    this.rotateStart = new Vector2();
    this.rotateEnd = new Vector2();
    this.rotateDelta = new Vector2();
    this.panStart = new Vector2();
    this.panEnd = new Vector2();
    this.panDelta = new Vector2();
    this.dollyStart = new Vector2();
    this.dollyEnd = new Vector2();
    this.dollyDelta = new Vector2();
    this.offset = new Vector3();
    this.lastPosition = new Vector3();
    this.lastQuaternion = new Quaternion();
    this.q = new Quaternion();
    this.v = new Vector3();
    this.vec = new Vector3();
    this.getPolarAngle = () => this.spherical.phi;
    this.getAzimuthalAngle = () => this.spherical.theta;
    this.saveState = () => {
      this.target0.copy(this.target);
      this.position0.copy(this.object.position);
      this.quaternion0.copy(this.object.quaternion);
      this.zoom0 = this.object.zoom;
    };
    this.reset = () => {
      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.quaternion.copy(this.quaternion0);
      this.object.zoom = this.zoom0;
      this.object.updateProjectionMatrix();
      this.dispatchEvent(this.changeEvent);
      this.update();
      this.state = -1;
    };
    this.dispose = () => {
      this.domElement.removeEventListener("contextmenu", this.onContextMenu, false);
      this.domElement.removeEventListener("mousedown", this.onMouseDown, false);
      this.domElement.removeEventListener("wheel", this.onMouseWheel, false);
      this.domElement.removeEventListener("touchstart", this.onTouchStart, false);
      this.domElement.removeEventListener("touchend", this.onTouchEnd, false);
      this.domElement.removeEventListener("touchmove", this.onTouchMove, false);
      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);
      this.domElement.removeEventListener("keydown", this.onKeyDown, false);
    };
    this.update = () => {
      const position = this.object.position;
      this.offset.copy(position).sub(this.target);
      if (this.trackball) {
        if (this.sphericalDelta.theta) {
          this.vec.set(0, 1, 0).applyQuaternion(this.object.quaternion);
          const factor = this.enableDamping ? this.dampingFactor : 1;
          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.theta * factor);
          this.object.quaternion.premultiply(this.q);
          this.offset.applyQuaternion(this.q);
        }
        if (this.sphericalDelta.phi) {
          this.vec.set(1, 0, 0).applyQuaternion(this.object.quaternion);
          const factor = this.enableDamping ? this.dampingFactor : 1;
          this.q.setFromAxisAngle(this.vec, this.sphericalDelta.phi * factor);
          this.object.quaternion.premultiply(this.q);
          this.offset.applyQuaternion(this.q);
        }
        this.offset.multiplyScalar(this.scale);
        this.offset.clampLength(this.minDistance, this.maxDistance);
      } else {
        this.offset.applyQuaternion(this.quat);
        if (this.autoRotate && this.state === -1) {
          this.rotateLeft(this.getAutoRotationAngle());
        }
        this.spherical.setFromVector3(this.offset);
        if (this.enableDamping) {
          this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
          this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;
        } else {
          this.spherical.theta += this.sphericalDelta.theta;
          this.spherical.phi += this.sphericalDelta.phi;
        }
        this.spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, this.spherical.theta));
        this.spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this.spherical.phi));
        this.spherical.makeSafe();
        this.spherical.radius *= this.scale;
        this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
        this.offset.setFromSpherical(this.spherical);
        this.offset.applyQuaternion(this.quatInverse);
      }
      if (this.enableDamping === true) {
        this.target.addScaledVector(this.panOffset, this.dampingFactor);
      } else {
        this.target.add(this.panOffset);
      }
      position.copy(this.target).add(this.offset);
      if (this.trackball === false) {
        this.object.lookAt(this.target);
      }
      if (this.enableDamping === true) {
        this.sphericalDelta.theta *= 1 - this.dampingFactor;
        this.sphericalDelta.phi *= 1 - this.dampingFactor;
        this.panOffset.multiplyScalar(1 - this.dampingFactor);
      } else {
        this.sphericalDelta.set(0, 0, 0);
        this.panOffset.set(0, 0, 0);
      }
      this.scale = 1;
      if (this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > this.EPS || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > this.EPS) {
        this.dispatchEvent(this.changeEvent);
        this.lastPosition.copy(this.object.position);
        this.lastQuaternion.copy(this.object.quaternion);
        this.zoomChanged = false;
        return true;
      }
      return false;
    };
    this.getAutoRotationAngle = () => 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
    this.getZoomScale = () => Math.pow(0.95, this.zoomSpeed);
    this.rotateLeft = (angle) => {
      this.sphericalDelta.theta -= angle;
    };
    this.rotateUp = (angle) => {
      this.sphericalDelta.phi -= angle;
    };
    this.panLeft = (distance, objectMatrix) => {
      this.v.setFromMatrixColumn(objectMatrix, 0);
      this.v.multiplyScalar(-distance);
      this.panOffset.add(this.v);
    };
    this.panUp = (distance, objectMatrix) => {
      if (this.screenSpacePanning === true) {
        this.v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        this.v.setFromMatrixColumn(objectMatrix, 0);
        this.v.crossVectors(this.object.up, this.v);
      }
      this.v.multiplyScalar(distance);
      this.panOffset.add(this.v);
    };
    this.pan = (deltaX, deltaY) => {
      const element = this.domElement;
      if (this.object instanceof PerspectiveCamera) {
        const position = this.object.position;
        this.offset.copy(position).sub(this.target);
        let targetDistance = this.offset.length();
        targetDistance *= Math.tan(this.object.fov / 2 * Math.PI / 180);
        this.panLeft(2 * deltaX * targetDistance / element.clientHeight, this.object.matrix);
        this.panUp(2 * deltaY * targetDistance / element.clientHeight, this.object.matrix);
      } else if (this.object.isOrthographicCamera) {
        this.panLeft(
          deltaX * (this.object.right - this.object.left) / this.object.zoom / element.clientWidth,
          this.object.matrix
        );
        this.panUp(
          deltaY * (this.object.top - this.object.bottom) / this.object.zoom / element.clientHeight,
          this.object.matrix
        );
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - pan disabled.");
        this.enablePan = false;
      }
    };
    this.dollyIn = (dollyScale) => {
      if (this.object instanceof PerspectiveCamera) {
        this.scale /= dollyScale;
      } else if (this.object instanceof OrthographicCamera) {
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * dollyScale));
        this.object.updateProjectionMatrix();
        this.zoomChanged = true;
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    };
    this.dollyOut = (dollyScale) => {
      if (this.object instanceof PerspectiveCamera) {
        this.scale *= dollyScale;
      } else if (this.object instanceof OrthographicCamera) {
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / dollyScale));
        this.object.updateProjectionMatrix();
        this.zoomChanged = true;
      } else {
        console.warn("WARNING: CameraControls.js encountered an unknown camera type - dolly/zoom disabled.");
        this.enableZoom = false;
      }
    };
    this.handleMouseDownRotate = (event) => {
      this.rotateStart.set(event.clientX, event.clientY);
    };
    this.handleMouseDownDolly = (event) => {
      this.dollyStart.set(event.clientX, event.clientY);
    };
    this.handleMouseDownPan = (event) => {
      this.panStart.set(event.clientX, event.clientY);
    };
    this.handleMouseMoveRotate = (event) => {
      this.rotateEnd.set(event.clientX, event.clientY);
      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
      const element = this.domElement;
      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight);
      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);
      this.rotateStart.copy(this.rotateEnd);
      this.update();
    };
    this.handleMouseMoveDolly = (event) => {
      this.dollyEnd.set(event.clientX, event.clientY);
      this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart);
      if (this.dollyDelta.y > 0) {
        this.dollyIn(this.getZoomScale());
      } else if (this.dollyDelta.y < 0) {
        this.dollyOut(this.getZoomScale());
      }
      this.dollyStart.copy(this.dollyEnd);
      this.update();
    };
    this.handleMouseMovePan = (event) => {
      this.panEnd.set(event.clientX, event.clientY);
      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
      this.pan(this.panDelta.x, this.panDelta.y);
      this.panStart.copy(this.panEnd);
      this.update();
    };
    this.handleMouseWheel = (event) => {
      if (event.deltaY < 0) {
        this.dollyOut(this.getZoomScale());
      } else if (event.deltaY > 0) {
        this.dollyIn(this.getZoomScale());
      }
      this.update();
    };
    this.handleKeyDown = (event) => {
      let needsUpdate = false;
      switch (event.code) {
        case this.keys.UP:
          this.pan(0, this.keyPanSpeed);
          needsUpdate = true;
          break;
        case this.keys.BOTTOM:
          this.pan(0, -this.keyPanSpeed);
          needsUpdate = true;
          break;
        case this.keys.LEFT:
          this.pan(this.keyPanSpeed, 0);
          needsUpdate = true;
          break;
        case this.keys.RIGHT:
          this.pan(-this.keyPanSpeed, 0);
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        this.update();
      }
    };
    this.handleTouchStartRotate = (event) => {
      if (event.touches.length == 1) {
        this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.rotateStart.set(x, y);
      }
    };
    this.handleTouchStartPan = (event) => {
      if (event.touches.length == 1) {
        this.panStart.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panStart.set(x, y);
      }
    };
    this.handleTouchStartDolly = (event) => {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      this.dollyStart.set(0, distance);
    };
    this.handleTouchStartDollyPan = (event) => {
      if (this.enableZoom)
        this.handleTouchStartDolly(event);
      if (this.enablePan)
        this.handleTouchStartPan(event);
    };
    this.handleTouchStartDollyRotate = (event) => {
      if (this.enableZoom)
        this.handleTouchStartDolly(event);
      if (this.enableRotate)
        this.handleTouchStartRotate(event);
    };
    this.handleTouchMoveRotate = (event) => {
      if (event.touches.length == 1) {
        this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.rotateEnd.set(x, y);
      }
      this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed);
      const element = this.domElement;
      this.rotateLeft(2 * Math.PI * this.rotateDelta.x / element.clientHeight);
      this.rotateUp(2 * Math.PI * this.rotateDelta.y / element.clientHeight);
      this.rotateStart.copy(this.rotateEnd);
    };
    this.handleTouchMovePan = (event) => {
      if (event.touches.length == 1) {
        this.panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
      } else {
        const x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        const y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
        this.panEnd.set(x, y);
      }
      this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed);
      this.pan(this.panDelta.x, this.panDelta.y);
      this.panStart.copy(this.panEnd);
    };
    this.handleTouchMoveDolly = (event) => {
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      this.dollyEnd.set(0, distance);
      this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed));
      this.dollyIn(this.dollyDelta.y);
      this.dollyStart.copy(this.dollyEnd);
    };
    this.handleTouchMoveDollyPan = (event) => {
      if (this.enableZoom)
        this.handleTouchMoveDolly(event);
      if (this.enablePan)
        this.handleTouchMovePan(event);
    };
    this.handleTouchMoveDollyRotate = (event) => {
      if (this.enableZoom)
        this.handleTouchMoveDolly(event);
      if (this.enableRotate)
        this.handleTouchMoveRotate(event);
    };
    this.onMouseDown = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      this.domElement.focus ? this.domElement.focus() : window.focus();
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = this.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = this.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = this.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (this.enableZoom === false)
            return;
          this.handleMouseDownDolly(event);
          this.state = 1;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (this.enablePan === false)
              return;
            this.handleMouseDownPan(event);
            this.state = 2;
          } else {
            if (this.enableRotate === false)
              return;
            this.handleMouseDownRotate(event);
            this.state = 0;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (this.enableRotate === false)
              return;
            this.handleMouseDownRotate(event);
            this.state = 0;
          } else {
            if (this.enablePan === false)
              return;
            this.handleMouseDownPan(event);
            this.state = 2;
          }
          break;
        default:
          this.state = -1;
      }
      if (this.state !== -1) {
        document.addEventListener("mousemove", this.onMouseMove, false);
        document.addEventListener("mouseup", this.onMouseUp, false);
        this.dispatchEvent(this.startEvent);
      }
    };
    this.onMouseMove = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (this.state) {
        case 0:
          if (this.enableRotate === false)
            return;
          this.handleMouseMoveRotate(event);
          break;
        case 1:
          if (this.enableZoom === false)
            return;
          this.handleMouseMoveDolly(event);
          break;
        case 2:
          if (this.enablePan === false)
            return;
          this.handleMouseMovePan(event);
          break;
      }
    };
    this.onMouseUp = () => {
      if (this.enabled === false)
        return;
      document.removeEventListener("mousemove", this.onMouseMove, false);
      document.removeEventListener("mouseup", this.onMouseUp, false);
      this.dispatchEvent(this.endEvent);
      this.state = -1;
    };
    this.onMouseWheel = (event) => {
      if (this.enabled === false || this.enableZoom === false || this.state !== -1 && this.state !== 0) {
        return;
      }
      event.preventDefault();
      this.dispatchEvent(this.startEvent);
      this.handleMouseWheel(event);
      this.dispatchEvent(this.endEvent);
    };
    this.onKeyDown = (event) => {
      if (this.enabled === false || this.enableKeys === false || this.enablePan === false)
        return;
      this.handleKeyDown(event);
    };
    this.onTouchStart = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (event.touches.length) {
        case 1:
          switch (this.touches.ONE) {
            case TOUCH.ROTATE:
              if (this.enableRotate === false)
                return;
              this.handleTouchStartRotate(event);
              this.state = 3;
              break;
            case TOUCH.PAN:
              if (this.enablePan === false)
                return;
              this.handleTouchStartPan(event);
              this.state = 4;
              break;
            default:
              this.state = -1;
          }
          break;
        case 2:
          switch (this.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (this.enableZoom === false && this.enablePan === false)
                return;
              this.handleTouchStartDollyPan(event);
              this.state = 5;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (this.enableZoom === false && this.enableRotate === false)
                return;
              this.handleTouchStartDollyRotate(event);
              this.state = 6;
              break;
            default:
              this.state = -1;
          }
          break;
        default:
          this.state = -1;
      }
      if (this.state !== -1) {
        this.dispatchEvent(this.startEvent);
      }
    };
    this.onTouchMove = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
      switch (this.state) {
        case 3:
          if (this.enableRotate === false)
            return;
          this.handleTouchMoveRotate(event);
          this.update();
          break;
        case 4:
          if (this.enablePan === false)
            return;
          this.handleTouchMovePan(event);
          this.update();
          break;
        case 5:
          if (this.enableZoom === false && this.enablePan === false)
            return;
          this.handleTouchMoveDollyPan(event);
          this.update();
          break;
        case 6:
          if (this.enableZoom === false && this.enableRotate === false)
            return;
          this.handleTouchMoveDollyRotate(event);
          this.update();
          break;
        default:
          this.state = -1;
      }
    };
    this.onTouchEnd = () => {
      if (this.enabled === false)
        return;
      this.dispatchEvent(this.endEvent);
      this.state = -1;
    };
    this.onContextMenu = (event) => {
      if (this.enabled === false)
        return;
      event.preventDefault();
    };
    if (domElement === void 0) {
      console.warn('THREE.CameraControls: The second parameter "domElement" is now mandatory.');
    }
    if (domElement instanceof Document) {
      console.error(
        'THREE.CameraControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
      );
    }
    this.object = object;
    this.domElement = domElement;
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN
    };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.quaternion0 = this.object.quaternion.clone();
    this.zoom0 = this.object.zoom;
    this.quat = new Quaternion().setFromUnitVectors(this.object.up, new Vector3(0, 1, 0));
    this.quatInverse = this.quat.clone().invert();
    this.lastPosition = new Vector3();
    this.lastQuaternion = new Quaternion();
    this.domElement.addEventListener("contextmenu", this.onContextMenu, false);
    this.domElement.addEventListener("mousedown", this.onMouseDown, false);
    this.domElement.addEventListener("wheel", this.onMouseWheel, false);
    this.domElement.addEventListener("touchstart", this.onTouchStart, false);
    this.domElement.addEventListener("touchend", this.onTouchEnd, false);
    this.domElement.addEventListener("touchmove", this.onTouchMove, false);
    this.domElement.addEventListener("keydown", this.onKeyDown, false);
    if (this.domElement.tabIndex === -1) {
      this.domElement.tabIndex = 0;
    }
    this.object.lookAt(this.target);
    this.update();
    this.saveState();
  }
  handleMouseUp() {
  }
  handleTouchEnd() {
  }
}
class OrbitControlsExp extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      RIGHT: MOUSE.PAN
    };
    this.touches = {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    };
  }
}
class MapControlsExp extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.mouseButtons = {
      LEFT: MOUSE.PAN,
      RIGHT: MOUSE.ROTATE
    };
    this.touches = {
      ONE: TOUCH.PAN,
      TWO: TOUCH.DOLLY_ROTATE
    };
  }
}
class TrackballControlsExp extends CameraControls {
  constructor(object, domElement) {
    super(object, domElement);
    this.trackball = true;
    this.screenSpacePanning = true;
    this.autoRotate = false;
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      RIGHT: MOUSE.PAN
    };
    this.touches = {
      ONE: TOUCH.ROTATE,
      TWO: TOUCH.DOLLY_PAN
    };
  }
}
export {
  CameraControls,
  MapControlsExp,
  OrbitControlsExp,
  STATE,
  TrackballControlsExp
};
