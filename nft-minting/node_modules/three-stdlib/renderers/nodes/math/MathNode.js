"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const Node = require("../core/Node.js");
const _MathNode = class extends Node {
  constructor(method, a, b = null) {
    super();
    this.method = method;
    this.a = a;
    this.b = b;
  }
  getType(builder) {
    const method = this.method;
    if (method === _MathNode.INVERSE_TRANSFORM_DIRETION) {
      return "vec3";
    } else {
      const typeA = this.a.getType(builder);
      if (this.b !== null) {
        if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
          return typeB;
        }
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getType(builder);
    let a = null, b = null;
    if (method === _MathNode.INVERSE_TRANSFORM_DIRETION) {
      a = this.a.build(builder, "vec3");
      b = this.b.build(builder, "mat4");
      return `normalize( ( vec4( ${a}, 0.0 ) * ${b} ).xyz )`;
    } else {
      a = this.a.build(builder, type);
      if (this.b !== null) {
        b = this.b.build(builder, type);
      }
    }
    if (b !== null) {
      return builder.format(`${method}( ${a}, ${b} )`, type, output);
    } else {
      return builder.format(`${method}( ${a} )`, type, output);
    }
  }
};
let MathNode = _MathNode;
__publicField(MathNode, "NORMALIZE", "normalize");
__publicField(MathNode, "INVERSE_TRANSFORM_DIRETION", "inverseTransformDirection");
module.exports = MathNode;
