"use strict";
const constants = require("./constants.js");
const THREE = require("three");
class WebGPURenderPipelines {
  constructor(renderer, properties, device, glslang, sampleCount, nodes) {
    this.renderer = renderer;
    this.properties = properties;
    this.device = device;
    this.glslang = glslang;
    this.sampleCount = sampleCount;
    this.nodes = nodes;
    this.pipelines = /* @__PURE__ */ new WeakMap();
    this.shaderAttributes = /* @__PURE__ */ new WeakMap();
    this.shaderModules = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map()
    };
  }
  get(object) {
    let pipeline = this.pipelines.get(object);
    if (pipeline === void 0) {
      const device = this.device;
      const properties = this.properties;
      const material = object.material;
      const nodeBuilder = this.nodes.get(material);
      const glslang = this.glslang;
      let moduleVertex = this.shaderModules.vertex.get(nodeBuilder.vertexShader);
      if (moduleVertex === void 0) {
        const byteCodeVertex = glslang.compileGLSL(nodeBuilder.vertexShader, "vertex");
        moduleVertex = {
          module: device.createShaderModule({ code: byteCodeVertex }),
          entryPoint: "main"
        };
        this.shaderModules.vertex.set(nodeBuilder.vertexShader, moduleVertex);
      }
      let moduleFragment = this.shaderModules.fragment.get(nodeBuilder.fragmentShader);
      if (moduleFragment === void 0) {
        const byteCodeFragment = glslang.compileGLSL(nodeBuilder.fragmentShader, "fragment");
        moduleFragment = {
          module: device.createShaderModule({ code: byteCodeFragment }),
          entryPoint: "main"
        };
        this.shaderModules.fragment.set(nodeBuilder.fragmentShader, moduleFragment);
      }
      const materialProperties = properties.get(material);
      if (materialProperties.disposeCallback === void 0) {
        const disposeCallback = onMaterialDispose.bind(this);
        materialProperties.disposeCallback = disposeCallback;
        material.addEventListener("dispose", disposeCallback);
      }
      const shaderAttributes = this._parseShaderAttributes(nodeBuilder.vertexShader);
      const vertexBuffers = [];
      const geometry = object.geometry;
      for (let attribute of shaderAttributes) {
        const name = attribute.name;
        const geometryAttribute = geometry.getAttribute(name);
        const stepMode = geometryAttribute !== void 0 && geometryAttribute.isInstancedBufferAttribute ? constants.GPUInputStepMode.Instance : constants.GPUInputStepMode.Vertex;
        vertexBuffers.push({
          arrayStride: attribute.arrayStride,
          attributes: [
            {
              shaderLocation: attribute.slot,
              offset: 0,
              format: attribute.format
            }
          ],
          stepMode
        });
      }
      let indexFormat;
      if (object.isLine) {
        const count = geometry.index ? geometry.index.count : geometry.attributes.position.count;
        indexFormat = count > 65535 ? constants.GPUIndexFormat.Uint32 : constants.GPUIndexFormat.Uint16;
      }
      let alphaBlend = {};
      let colorBlend = {};
      if (material.transparent === true && material.blending !== THREE.NoBlending) {
        alphaBlend = this._getAlphaBlend(material);
        colorBlend = this._getColorBlend(material);
      }
      let stencilFront = {};
      if (material.stencilWrite === true) {
        stencilFront = {
          compare: this._getStencilCompare(material),
          failOp: this._getStencilOperation(material.stencilFail),
          depthFailOp: this._getStencilOperation(material.stencilZFail),
          passOp: this._getStencilOperation(material.stencilZPass)
        };
      }
      const primitiveTopology = this._getPrimitiveTopology(object);
      const rasterizationState = this._getRasterizationStateDescriptor(material);
      const colorWriteMask = this._getColorWriteMask(material);
      const depthCompare = this._getDepthCompare(material);
      const colorFormat = this._getColorFormat(this.renderer);
      const depthStencilFormat = this._getDepthStencilFormat(this.renderer);
      pipeline = device.createRenderPipeline({
        vertexStage: moduleVertex,
        fragmentStage: moduleFragment,
        primitiveTopology,
        rasterizationState,
        colorStates: [
          {
            format: colorFormat,
            alphaBlend,
            colorBlend,
            writeMask: colorWriteMask
          }
        ],
        depthStencilState: {
          format: depthStencilFormat,
          depthWriteEnabled: material.depthWrite,
          depthCompare,
          stencilFront,
          stencilBack: {},
          stencilReadMask: material.stencilFuncMask,
          stencilWriteMask: material.stencilWriteMask
        },
        vertexState: {
          indexFormat,
          vertexBuffers
        },
        sampleCount: this.sampleCount
      });
      this.pipelines.set(object, pipeline);
      this.shaderAttributes.set(pipeline, shaderAttributes);
    }
    return pipeline;
  }
  getShaderAttributes(pipeline) {
    return this.shaderAttributes.get(pipeline);
  }
  dispose() {
    this.pipelines = /* @__PURE__ */ new WeakMap();
    this.shaderAttributes = /* @__PURE__ */ new WeakMap();
    this.shaderModules = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map()
    };
  }
  _getArrayStride(type) {
    if (type === "float")
      return 4;
    if (type === "vec2")
      return 8;
    if (type === "vec3")
      return 12;
    if (type === "vec4")
      return 16;
    if (type === "int")
      return 4;
    if (type === "ivec2")
      return 8;
    if (type === "ivec3")
      return 12;
    if (type === "ivec4")
      return 16;
    if (type === "uint")
      return 4;
    if (type === "uvec2")
      return 8;
    if (type === "uvec3")
      return 12;
    if (type === "uvec4")
      return 16;
    console.error("THREE.WebGPURenderer: Shader variable type not supported yet.", type);
  }
  _getAlphaBlend(material) {
    const blending = material.blending;
    const premultipliedAlpha = material.premultipliedAlpha;
    let alphaBlend = void 0;
    switch (blending) {
      case THREE.NormalBlending:
        if (premultipliedAlpha === false) {
          alphaBlend = {
            srcFactor: constants.GPUBlendFactor.One,
            dstFactor: constants.GPUBlendFactor.OneMinusSrcAlpha,
            operation: constants.GPUBlendOperation.Add
          };
        }
        break;
      case THREE.AdditiveBlending:
        break;
      case THREE.SubtractiveBlending:
        if (premultipliedAlpha === true) {
          alphaBlend = {
            srcFactor: constants.GPUBlendFactor.OneMinusSrcColor,
            dstFactor: constants.GPUBlendFactor.OneMinusSrcAlpha,
            operation: constants.GPUBlendOperation.Add
          };
        }
        break;
      case THREE.MultiplyBlending:
        if (premultipliedAlpha === true) {
          alphaBlend = {
            srcFactor: constants.GPUBlendFactor.Zero,
            dstFactor: constants.GPUBlendFactor.SrcAlpha,
            operation: constants.GPUBlendOperation.Add
          };
        }
        break;
      case THREE.CustomBlending:
        const blendSrcAlpha = material.blendSrcAlpha;
        const blendDstAlpha = material.blendDstAlpha;
        const blendEquationAlpha = material.blendEquationAlpha;
        if (blendSrcAlpha !== null && blendDstAlpha !== null && blendEquationAlpha !== null) {
          alphaBlend = {
            srcFactor: this._getBlendFactor(blendSrcAlpha),
            dstFactor: this._getBlendFactor(blendDstAlpha),
            operation: this._getBlendOperation(blendEquationAlpha)
          };
        }
        break;
      default:
        console.error("THREE.WebGPURenderer: Blending not supported.", blending);
    }
    return alphaBlend;
  }
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case THREE.ZeroFactor:
        blendFactor = constants.GPUBlendFactor.Zero;
        break;
      case THREE.OneFactor:
        blendFactor = constants.GPUBlendFactor.One;
        break;
      case THREE.SrcColorFactor:
        blendFactor = constants.GPUBlendFactor.SrcColor;
        break;
      case THREE.OneMinusSrcColorFactor:
        blendFactor = constants.GPUBlendFactor.OneMinusSrcColor;
        break;
      case THREE.SrcAlphaFactor:
        blendFactor = constants.GPUBlendFactor.SrcAlpha;
        break;
      case THREE.OneMinusSrcAlphaFactor:
        blendFactor = constants.GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case THREE.DstColorFactor:
        blendFactor = constants.GPUBlendFactor.DstColor;
        break;
      case THREE.OneMinusDstColorFactor:
        blendFactor = constants.GPUBlendFactor.OneMinusDstColor;
        break;
      case THREE.DstAlphaFactor:
        blendFactor = constants.GPUBlendFactor.DstAlpha;
        break;
      case THREE.OneMinusDstAlphaFactor:
        blendFactor = constants.GPUBlendFactor.OneMinusDstAlpha;
        break;
      case THREE.SrcAlphaSaturateFactor:
        blendFactor = constants.GPUBlendFactor.SrcAlphaSaturated;
        break;
      case constants.BlendColorFactor:
        blendFactor = constants.GPUBlendFactor.BlendColor;
        break;
      case constants.OneMinusBlendColorFactor:
        blendFactor = constants.GPUBlendFactor.OneMinusBlendColor;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case THREE.AddEquation:
        blendOperation = constants.GPUBlendOperation.Add;
        break;
      case THREE.SubtractEquation:
        blendOperation = constants.GPUBlendOperation.Subtract;
        break;
      case THREE.ReverseSubtractEquation:
        blendOperation = constants.GPUBlendOperation.ReverseSubtract;
        break;
      case THREE.MinEquation:
        blendOperation = constants.GPUBlendOperation.Min;
        break;
      case THREE.MaxEquation:
        blendOperation = constants.GPUBlendOperation.Max;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  _getColorBlend(material) {
    const blending = material.blending;
    const premultipliedAlpha = material.premultipliedAlpha;
    const colorBlend = {
      srcFactor: null,
      dstFactor: null,
      operation: null
    };
    switch (blending) {
      case THREE.NormalBlending:
        colorBlend.srcFactor = premultipliedAlpha === true ? constants.GPUBlendFactor.One : constants.GPUBlendFactor.SrcAlpha;
        colorBlend.dstFactor = constants.GPUBlendFactor.OneMinusSrcAlpha;
        colorBlend.operation = constants.GPUBlendOperation.Add;
        break;
      case THREE.AdditiveBlending:
        colorBlend.srcFactor = premultipliedAlpha === true ? constants.GPUBlendFactor.One : constants.GPUBlendFactor.SrcAlpha;
        colorBlend.operation = constants.GPUBlendOperation.Add;
        break;
      case THREE.SubtractiveBlending:
        colorBlend.srcFactor = constants.GPUBlendFactor.Zero;
        colorBlend.dstFactor = premultipliedAlpha === true ? constants.GPUBlendFactor.Zero : constants.GPUBlendFactor.OneMinusSrcColor;
        colorBlend.operation = constants.GPUBlendOperation.Add;
        break;
      case THREE.MultiplyBlending:
        colorBlend.srcFactor = constants.GPUBlendFactor.Zero;
        colorBlend.dstFactor = constants.GPUBlendFactor.SrcColor;
        colorBlend.operation = constants.GPUBlendOperation.Add;
        break;
      case THREE.CustomBlending:
        colorBlend.srcFactor = this._getBlendFactor(material.blendSrc);
        colorBlend.dstFactor = this._getBlendFactor(material.blendDst);
        colorBlend.operation = this._getBlendOperation(material.blendEquation);
        break;
      default:
        console.error("THREE.WebGPURenderer: Blending not supported.", blending);
    }
    return colorBlend;
  }
  _getColorFormat(renderer) {
    let format;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget !== null) {
      const renderTargetProperties = this.properties.get(renderTarget);
      format = renderTargetProperties.colorTextureFormat;
    } else {
      format = constants.GPUTextureFormat.BRGA8Unorm;
    }
    return format;
  }
  _getColorWriteMask(material) {
    return material.colorWrite === true ? constants.GPUColorWriteFlags.All : constants.GPUColorWriteFlags.None;
  }
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = constants.GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case THREE.NeverDepth:
          depthCompare = constants.GPUCompareFunction.Never;
          break;
        case THREE.AlwaysDepth:
          depthCompare = constants.GPUCompareFunction.Always;
          break;
        case THREE.LessDepth:
          depthCompare = constants.GPUCompareFunction.Less;
          break;
        case THREE.LessEqualDepth:
          depthCompare = constants.GPUCompareFunction.LessEqual;
          break;
        case THREE.EqualDepth:
          depthCompare = constants.GPUCompareFunction.Equal;
          break;
        case THREE.GreaterEqualDepth:
          depthCompare = constants.GPUCompareFunction.GreaterEqual;
          break;
        case THREE.GreaterDepth:
          depthCompare = constants.GPUCompareFunction.Greater;
          break;
        case THREE.NotEqualDepth:
          depthCompare = constants.GPUCompareFunction.NotEqual;
          break;
        default:
          console.error("THREE.WebGPURenderer: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
  _getDepthStencilFormat(renderer) {
    let format;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget !== null) {
      const renderTargetProperties = this.properties.get(renderTarget);
      format = renderTargetProperties.depthTextureFormat;
    } else {
      format = constants.GPUTextureFormat.Depth24PlusStencil8;
    }
    return format;
  }
  _getPrimitiveTopology(object) {
    if (object.isMesh)
      return constants.GPUPrimitiveTopology.TriangleList;
    else if (object.isPoints)
      return constants.GPUPrimitiveTopology.PointList;
    else if (object.isLine)
      return constants.GPUPrimitiveTopology.LineStrip;
    else if (object.isLineSegments)
      return constants.GPUPrimitiveTopology.LineList;
  }
  _getRasterizationStateDescriptor(material) {
    const descriptor = {};
    switch (material.side) {
      case THREE.FrontSide:
        descriptor.frontFace = constants.GPUFrontFace.CCW;
        descriptor.cullMode = constants.GPUCullMode.Back;
        break;
      case THREE.BackSide:
        descriptor.frontFace = constants.GPUFrontFace.CW;
        descriptor.cullMode = constants.GPUCullMode.Back;
        break;
      case THREE.DoubleSide:
        descriptor.frontFace = constants.GPUFrontFace.CCW;
        descriptor.cullMode = constants.GPUCullMode.None;
        break;
      default:
        console.error("THREE.WebGPURenderer: Unknown Material.side value.", material.side);
        break;
    }
    return descriptor;
  }
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case THREE.NeverStencilFunc:
        stencilCompare = constants.GPUCompareFunction.Never;
        break;
      case THREE.AlwaysStencilFunc:
        stencilCompare = constants.GPUCompareFunction.Always;
        break;
      case THREE.LessStencilFunc:
        stencilCompare = constants.GPUCompareFunction.Less;
        break;
      case THREE.LessEqualStencilFunc:
        stencilCompare = constants.GPUCompareFunction.LessEqual;
        break;
      case THREE.EqualStencilFunc:
        stencilCompare = constants.GPUCompareFunction.Equal;
        break;
      case THREE.GreaterEqualStencilFunc:
        stencilCompare = constants.GPUCompareFunction.GreaterEqual;
        break;
      case THREE.GreaterStencilFunc:
        stencilCompare = constants.GPUCompareFunction.Greater;
        break;
      case THREE.NotEqualStencilFunc:
        stencilCompare = constants.GPUCompareFunction.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case THREE.KeepStencilOp:
        stencilOperation = constants.GPUStencilOperation.Keep;
        break;
      case THREE.ZeroStencilOp:
        stencilOperation = constants.GPUStencilOperation.Zero;
        break;
      case THREE.ReplaceStencilOp:
        stencilOperation = constants.GPUStencilOperation.Replace;
        break;
      case THREE.InvertStencilOp:
        stencilOperation = constants.GPUStencilOperation.Invert;
        break;
      case THREE.IncrementStencilOp:
        stencilOperation = constants.GPUStencilOperation.IncrementClamp;
        break;
      case THREE.DecrementStencilOp:
        stencilOperation = constants.GPUStencilOperation.DecrementClamp;
        break;
      case THREE.IncrementWrapStencilOp:
        stencilOperation = constants.GPUStencilOperation.IncrementWrap;
        break;
      case THREE.DecrementWrapStencilOp:
        stencilOperation = constants.GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  _getVertexFormat(type) {
    if (type === "float")
      return constants.GPUVertexFormat.Float;
    if (type === "vec2")
      return constants.GPUVertexFormat.Float2;
    if (type === "vec3")
      return constants.GPUVertexFormat.Float3;
    if (type === "vec4")
      return constants.GPUVertexFormat.Float4;
    if (type === "int")
      return constants.GPUVertexFormat.Int;
    if (type === "ivec2")
      return constants.GPUVertexFormat.Int2;
    if (type === "ivec3")
      return constants.GPUVertexFormat.Int3;
    if (type === "ivec4")
      return constants.GPUVertexFormat.Int4;
    if (type === "uint")
      return constants.GPUVertexFormat.UInt;
    if (type === "uvec2")
      return constants.GPUVertexFormat.UInt2;
    if (type === "uvec3")
      return constants.GPUVertexFormat.UInt3;
    if (type === "uvec4")
      return constants.GPUVertexFormat.UInt4;
    console.error("THREE.WebGPURenderer: Shader variable type not supported yet.", type);
  }
  _parseShaderAttributes(shader) {
    const regex = /\s*layout\s*\(\s*location\s*=\s*(?<location>[0-9]+)\s*\)\s*in\s+(?<type>\w+)\s+(?<name>\w+)\s*;/gim;
    let shaderAttribute = null;
    const attributes = [];
    while (shaderAttribute = regex.exec(shader)) {
      const shaderLocation = parseInt(shaderAttribute.groups.location);
      const arrayStride = this._getArrayStride(shaderAttribute.groups.type);
      const vertexFormat = this._getVertexFormat(shaderAttribute.groups.type);
      attributes.push({
        name: shaderAttribute.groups.name,
        arrayStride,
        slot: shaderLocation,
        format: vertexFormat
      });
    }
    return attributes.sort(function(a, b) {
      return a.slot - b.slot;
    });
  }
}
function onMaterialDispose(event) {
  const properties = this.properties;
  const nodes = this.nodes;
  const shaderModules = this.shaderModules;
  const material = event.target;
  const materialProperties = properties.get(material);
  const nodeBuilder = nodes.get(material);
  material.removeEventListener("dispose", materialProperties.disposeCallback);
  properties.remove(material);
  nodes.remove(material);
  shaderModules.vertex.delete(nodeBuilder.vertexShader);
  shaderModules.fragment.delete(nodeBuilder.fragmentShader);
}
module.exports = WebGPURenderPipelines;
