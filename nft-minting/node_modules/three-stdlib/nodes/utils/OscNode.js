"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const Node = require("../core/Node.js");
const TimerNode = require("./TimerNode.js");
const ShaderNode = require("../ShaderNode.js");
const _OscNode = class extends Node {
  constructor(method = _OscNode.SINE, timeNode = new TimerNode()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = ShaderNode.add(ShaderNode.mul(ShaderNode.sin(ShaderNode.mul(ShaderNode.add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = ShaderNode.round(ShaderNode.fract(timeNode));
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = ShaderNode.abs(ShaderNode.sub(1, ShaderNode.mul(ShaderNode.fract(ShaderNode.add(timeNode, 0.5)), 2)));
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = ShaderNode.fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
let OscNode = _OscNode;
__publicField(OscNode, "SINE", "sine");
__publicField(OscNode, "SQUARE", "square");
__publicField(OscNode, "TRIANGLE", "triangle");
__publicField(OscNode, "SAWTOOTH", "sawtooth");
module.exports = OscNode;
