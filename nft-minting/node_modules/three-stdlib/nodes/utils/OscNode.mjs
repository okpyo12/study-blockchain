var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import Node from "../core/Node.mjs";
import TimerNode from "./TimerNode.mjs";
import { add, mul, sin, round, fract, abs, sub } from "../ShaderNode.mjs";
const _OscNode = class extends Node {
  constructor(method = _OscNode.SINE, timeNode = new TimerNode()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
let OscNode = _OscNode;
__publicField(OscNode, "SINE", "sine");
__publicField(OscNode, "SQUARE", "square");
__publicField(OscNode, "TRIANGLE", "triangle");
__publicField(OscNode, "SAWTOOTH", "sawtooth");
export {
  OscNode as default
};
