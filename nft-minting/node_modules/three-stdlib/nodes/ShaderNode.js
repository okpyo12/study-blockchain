"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const PropertyNode = require("./core/PropertyNode.js");
const VarNode = require("./core/VarNode.js");
const AttributeNode = require("./core/AttributeNode.js");
const ConstNode = require("./core/ConstNode.js");
const UniformNode = require("./core/UniformNode.js");
const BufferNode = require("./accessors/BufferNode.js");
const PositionNode = require("./accessors/PositionNode.js");
const NormalNode = require("./accessors/NormalNode.js");
const CameraNode = require("./accessors/CameraNode.js");
const ModelNode = require("./accessors/ModelNode.js");
const TextureNode = require("./accessors/TextureNode.js");
const UVNode = require("./accessors/UVNode.js");
const OperatorNode = require("./math/OperatorNode.js");
const CondNode = require("./math/CondNode.js");
const MathNode = require("./math/MathNode.js");
const ArrayElementNode = require("./utils/ArrayElementNode.js");
const ConvertNode = require("./utils/ConvertNode.js");
const JoinNode = require("./utils/JoinNode.js");
const SplitNode = require("./utils/SplitNode.js");
const NodeUtils = require("./core/NodeUtils.js");
const NodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(new ShaderNodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return new ShaderNodeObject(new SplitNode(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return new ShaderNodeObject(new ArrayElementNode(node, uint(Number(prop))));
      }
    }
    return node[prop];
  }
};
const nodeObjects = /* @__PURE__ */ new WeakMap();
const ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return new ShaderNodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if (obj.isNode === true) {
      let nodeObject2 = nodeObjects.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, NodeHandler);
        nodeObjects.set(obj, nodeObject2);
        nodeObjects.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
const ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = new ShaderNodeObject(objects[name]);
  }
  return objects;
};
const getShaderNodeArray = (array) => {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = new ShaderNodeObject(array[i]);
  }
  return array;
};
const ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(...getShaderNodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params)));
    };
  } else {
    factor = new ShaderNodeObject(factor);
    return (...params) => {
      return new ShaderNodeObject(new NodeClass(scope, ...getShaderNodeArray(params), factor));
    };
  }
};
const ShaderNodeScript = function(jsFunc) {
  return (inputs, builder) => {
    new ShaderNodeObjects(inputs);
    return new ShaderNodeObject(jsFunc(inputs, builder));
  };
};
const bools = [false, true];
const uints = [0, 1, 2, 3];
const ints = [-1, -2];
const floats = [
  0.5,
  1.5,
  1 / 3,
  1e-6,
  1e6,
  Math.PI,
  Math.PI * 2,
  1 / Math.PI,
  2 / Math.PI,
  1 / (Math.PI * 2),
  Math.PI / 2
];
const boolsCacheMap = /* @__PURE__ */ new Map();
for (let bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode(bool2));
const uintsCacheMap = /* @__PURE__ */ new Map();
for (let uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode(uint2, "uint"));
const intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (let int2 of ints)
  intsCacheMap.set(int2, new ConstNode(int2, "int"));
const floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (let float2 of floats)
  floatsCacheMap.set(float2, new ConstNode(float2));
for (let float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode(-float2));
const constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
const getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value);
  }
};
const ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode(NodeUtils.getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [NodeUtils.getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      return nodeObject(new ConvertNode(nodes.length === 1 ? nodes[0] : new JoinNode(nodes), type));
    }
  };
};
const ShaderNode = new Proxy(ShaderNodeScript, NodeHandler);
const nodeObject = (val) => {
  return new ShaderNodeObject(val);
};
const uniform = (value) => {
  var _a;
  value = value.isNode === true ? ((_a = value.node) == null ? void 0 : _a.value) || value.value : value;
  return nodeObject(new UniformNode(value, value.nodeType));
};
const label = (node, name) => {
  node = nodeObject(node);
  if (node.isVarNode === true) {
    node.name = name;
    return node;
  }
  return nodeObject(new VarNode(node, name));
};
const temp = (node) => nodeObject(new VarNode(nodeObject(node)));
const color = new ConvertType("color");
const float = new ConvertType("float", floatsCacheMap);
const int = new ConvertType("int", intsCacheMap);
const uint = new ConvertType("uint", uintsCacheMap);
const bool = new ConvertType("bool", boolsCacheMap);
const vec2 = new ConvertType("vec2");
const ivec2 = new ConvertType("ivec2");
const uvec2 = new ConvertType("uvec2");
const bvec2 = new ConvertType("bvec2");
const vec3 = new ConvertType("vec3");
const ivec3 = new ConvertType("ivec3");
const uvec3 = new ConvertType("uvec3");
const bvec3 = new ConvertType("bvec3");
const vec4 = new ConvertType("vec4");
const ivec4 = new ConvertType("ivec4");
const uvec4 = new ConvertType("uvec4");
const bvec4 = new ConvertType("bvec4");
const mat3 = new ConvertType("mat3");
const imat3 = new ConvertType("imat3");
const umat3 = new ConvertType("umat3");
const bmat3 = new ConvertType("bmat3");
const mat4 = new ConvertType("mat4");
const imat4 = new ConvertType("imat4");
const umat4 = new ConvertType("umat4");
const bmat4 = new ConvertType("bmat4");
const join = (...params) => nodeObject(new JoinNode(getShaderNodeArray(params)));
const uv = (...params) => nodeObject(new UVNode(...params));
const attribute = (...params) => nodeObject(new AttributeNode(...params));
const buffer = (...params) => nodeObject(new BufferNode(...params));
const texture = (...params) => nodeObject(new TextureNode(...params));
const sampler = (texture2) => nodeObject(new ConvertNode(texture2.isNode === true ? texture2 : new TextureNode(texture2), "sampler"));
const cond = (...params) => nodeObject(new CondNode(...getShaderNodeArray(params)));
const addTo = (varNode, ...params) => {
  varNode.node = add(varNode.node, ...getShaderNodeArray(params));
  return nodeObject(varNode);
};
const add = new ShaderNodeProxy(OperatorNode, "+");
const sub = new ShaderNodeProxy(OperatorNode, "-");
const mul = new ShaderNodeProxy(OperatorNode, "*");
const div = new ShaderNodeProxy(OperatorNode, "/");
const remainder = new ShaderNodeProxy(OperatorNode, "%");
const equal = new ShaderNodeProxy(OperatorNode, "==");
const assign = new ShaderNodeProxy(OperatorNode, "=");
const lessThan = new ShaderNodeProxy(OperatorNode, "<");
const greaterThan = new ShaderNodeProxy(OperatorNode, ">");
const lessThanEqual = new ShaderNodeProxy(OperatorNode, "<=");
const greaterThanEqual = new ShaderNodeProxy(OperatorNode, ">=");
const and = new ShaderNodeProxy(OperatorNode, "&&");
const or = new ShaderNodeProxy(OperatorNode, "||");
const xor = new ShaderNodeProxy(OperatorNode, "^^");
const bitAnd = new ShaderNodeProxy(OperatorNode, "&");
const bitOr = new ShaderNodeProxy(OperatorNode, "|");
const bitXor = new ShaderNodeProxy(OperatorNode, "^");
const shiftLeft = new ShaderNodeProxy(OperatorNode, "<<");
const shiftRight = new ShaderNodeProxy(OperatorNode, ">>");
const element = new ShaderNodeProxy(ArrayElementNode);
const normalGeometry = new ShaderNodeObject(new NormalNode(NormalNode.GEOMETRY));
const normalLocal = new ShaderNodeObject(new NormalNode(NormalNode.LOCAL));
const normalWorld = new ShaderNodeObject(new NormalNode(NormalNode.WORLD));
const normalView = new ShaderNodeObject(new NormalNode(NormalNode.VIEW));
const transformedNormalView = new ShaderNodeObject(
  new VarNode(new NormalNode(NormalNode.VIEW), "TransformedNormalView", "vec3")
);
const positionLocal = new ShaderNodeObject(new PositionNode(PositionNode.LOCAL));
const positionWorld = new ShaderNodeObject(new PositionNode(PositionNode.WORLD));
const positionView = new ShaderNodeObject(new PositionNode(PositionNode.VIEW));
const positionViewDirection = new ShaderNodeObject(new PositionNode(PositionNode.VIEW_DIRECTION));
const viewMatrix = new ShaderNodeObject(new ModelNode(ModelNode.VIEW_MATRIX));
const cameraPosition = new ShaderNodeObject(new CameraNode(CameraNode.POSITION));
const diffuseColor = new ShaderNodeObject(new PropertyNode("DiffuseColor", "vec4"));
const roughness = new ShaderNodeObject(new PropertyNode("Roughness", "float"));
const metalness = new ShaderNodeObject(new PropertyNode("Metalness", "float"));
const alphaTest = new ShaderNodeObject(new PropertyNode("AlphaTest", "float"));
const specularColor = new ShaderNodeObject(new PropertyNode("SpecularColor", "color"));
const abs = new ShaderNodeProxy(MathNode, "abs");
const acos = new ShaderNodeProxy(MathNode, "acos");
const asin = new ShaderNodeProxy(MathNode, "asin");
const atan = new ShaderNodeProxy(MathNode, "atan");
const ceil = new ShaderNodeProxy(MathNode, "ceil");
const clamp = new ShaderNodeProxy(MathNode, "clamp");
const cos = new ShaderNodeProxy(MathNode, "cos");
const cross = new ShaderNodeProxy(MathNode, "cross");
const degrees = new ShaderNodeProxy(MathNode, "degrees");
const dFdx = new ShaderNodeProxy(MathNode, "dFdx");
const dFdy = new ShaderNodeProxy(MathNode, "dFdy");
const distance = new ShaderNodeProxy(MathNode, "distance");
const dot = new ShaderNodeProxy(MathNode, "dot");
const exp = new ShaderNodeProxy(MathNode, "exp");
const exp2 = new ShaderNodeProxy(MathNode, "exp2");
const faceforward = new ShaderNodeProxy(MathNode, "faceforward");
const floor = new ShaderNodeProxy(MathNode, "floor");
const fract = new ShaderNodeProxy(MathNode, "fract");
const invert = new ShaderNodeProxy(MathNode, "invert");
const inversesqrt = new ShaderNodeProxy(MathNode, "inversesqrt");
const length = new ShaderNodeProxy(MathNode, "length");
const log = new ShaderNodeProxy(MathNode, "log");
const log2 = new ShaderNodeProxy(MathNode, "log2");
const max = new ShaderNodeProxy(MathNode, "max");
const min = new ShaderNodeProxy(MathNode, "min");
const mix = new ShaderNodeProxy(MathNode, "mix");
const mod = new ShaderNodeProxy(MathNode, "mod");
const negate = new ShaderNodeProxy(MathNode, "negate");
const normalize = new ShaderNodeProxy(MathNode, "normalize");
const pow = new ShaderNodeProxy(MathNode, "pow");
const pow2 = new ShaderNodeProxy(MathNode, "pow", 2);
const pow3 = new ShaderNodeProxy(MathNode, "pow", 3);
const pow4 = new ShaderNodeProxy(MathNode, "pow", 4);
const radians = new ShaderNodeProxy(MathNode, "radians");
const reflect = new ShaderNodeProxy(MathNode, "reflect");
const refract = new ShaderNodeProxy(MathNode, "refract");
const round = new ShaderNodeProxy(MathNode, "round");
const saturate = new ShaderNodeProxy(MathNode, "saturate");
const sign = new ShaderNodeProxy(MathNode, "sign");
const sin = new ShaderNodeProxy(MathNode, "sin");
const smoothstep = new ShaderNodeProxy(MathNode, "smoothstep");
const sqrt = new ShaderNodeProxy(MathNode, "sqrt");
const step = new ShaderNodeProxy(MathNode, "step");
const tan = new ShaderNodeProxy(MathNode, "tan");
const transformDirection = new ShaderNodeProxy(MathNode, "transformDirection");
const EPSILON = float(1e-6);
const INFINITY = float(1e6);
exports.EPSILON = EPSILON;
exports.INFINITY = INFINITY;
exports.ShaderNode = ShaderNode;
exports.abs = abs;
exports.acos = acos;
exports.add = add;
exports.addTo = addTo;
exports.alphaTest = alphaTest;
exports.and = and;
exports.asin = asin;
exports.assign = assign;
exports.atan = atan;
exports.attribute = attribute;
exports.bitAnd = bitAnd;
exports.bitOr = bitOr;
exports.bitXor = bitXor;
exports.bmat3 = bmat3;
exports.bmat4 = bmat4;
exports.bool = bool;
exports.buffer = buffer;
exports.bvec2 = bvec2;
exports.bvec3 = bvec3;
exports.bvec4 = bvec4;
exports.cameraPosition = cameraPosition;
exports.ceil = ceil;
exports.clamp = clamp;
exports.color = color;
exports.cond = cond;
exports.cos = cos;
exports.cross = cross;
exports.dFdx = dFdx;
exports.dFdy = dFdy;
exports.degrees = degrees;
exports.diffuseColor = diffuseColor;
exports.distance = distance;
exports.div = div;
exports.dot = dot;
exports.element = element;
exports.equal = equal;
exports.exp = exp;
exports.exp2 = exp2;
exports.faceforward = faceforward;
exports.float = float;
exports.floor = floor;
exports.fract = fract;
exports.greaterThan = greaterThan;
exports.greaterThanEqual = greaterThanEqual;
exports.imat3 = imat3;
exports.imat4 = imat4;
exports.int = int;
exports.inversesqrt = inversesqrt;
exports.invert = invert;
exports.ivec2 = ivec2;
exports.ivec3 = ivec3;
exports.ivec4 = ivec4;
exports.join = join;
exports.label = label;
exports.length = length;
exports.lessThan = lessThan;
exports.lessThanEqual = lessThanEqual;
exports.log = log;
exports.log2 = log2;
exports.mat3 = mat3;
exports.mat4 = mat4;
exports.max = max;
exports.metalness = metalness;
exports.min = min;
exports.mix = mix;
exports.mod = mod;
exports.mul = mul;
exports.negate = negate;
exports.nodeObject = nodeObject;
exports.normalGeometry = normalGeometry;
exports.normalLocal = normalLocal;
exports.normalView = normalView;
exports.normalWorld = normalWorld;
exports.normalize = normalize;
exports.or = or;
exports.positionLocal = positionLocal;
exports.positionView = positionView;
exports.positionViewDirection = positionViewDirection;
exports.positionWorld = positionWorld;
exports.pow = pow;
exports.pow2 = pow2;
exports.pow3 = pow3;
exports.pow4 = pow4;
exports.radians = radians;
exports.reflect = reflect;
exports.refract = refract;
exports.remainder = remainder;
exports.roughness = roughness;
exports.round = round;
exports.sampler = sampler;
exports.saturate = saturate;
exports.shiftLeft = shiftLeft;
exports.shiftRight = shiftRight;
exports.sign = sign;
exports.sin = sin;
exports.smoothstep = smoothstep;
exports.specularColor = specularColor;
exports.sqrt = sqrt;
exports.step = step;
exports.sub = sub;
exports.tan = tan;
exports.temp = temp;
exports.texture = texture;
exports.transformDirection = transformDirection;
exports.transformedNormalView = transformedNormalView;
exports.uint = uint;
exports.umat3 = umat3;
exports.umat4 = umat4;
exports.uniform = uniform;
exports.uv = uv;
exports.uvec2 = uvec2;
exports.uvec3 = uvec3;
exports.uvec4 = uvec4;
exports.vec2 = vec2;
exports.vec3 = vec3;
exports.vec4 = vec4;
exports.viewMatrix = viewMatrix;
exports.xor = xor;
