"use strict";
const THREE = require("three");
const NodeUtils = require("../core/NodeUtils.js");
class NodeMaterial extends THREE.ShaderMaterial {
  constructor() {
    super();
    this.type = this.constructor.name;
    this.lights = true;
  }
  setDefaultValues(values) {
    let value;
    for (const property in values) {
      value = values[property];
      if (this[property] === void 0) {
        if (value && typeof value.clone === "function") {
          this[property] = value.clone();
        } else {
          this[property] = value;
        }
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = THREE.Material.prototype.toJSON.call(this, meta);
    const nodeKeys = NodeUtils.getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta).uuid;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
}
NodeMaterial.prototype.isNodeMaterial = true;
module.exports = NodeMaterial;
