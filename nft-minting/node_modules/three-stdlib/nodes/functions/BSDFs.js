"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const ShaderNode = require("../ShaderNode.js");
const F_Schlick = new ShaderNode.ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = ShaderNode.exp2(ShaderNode.mul(ShaderNode.sub(ShaderNode.mul(-5.55473, dotVH), 6.98316), dotVH));
  return ShaderNode.add(ShaderNode.mul(f0, ShaderNode.sub(1, fresnel)), ShaderNode.mul(f90, fresnel));
});
const BRDF_Lambert = new ShaderNode.ShaderNode((inputs) => {
  return ShaderNode.mul(1 / Math.PI, inputs.diffuseColor);
});
const getDistanceAttenuation = new ShaderNode.ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  return ShaderNode.cond(
    ShaderNode.and(ShaderNode.greaterThan(cutoffDistance, 0), ShaderNode.greaterThan(decayExponent, 0)),
    ShaderNode.pow(ShaderNode.saturate(ShaderNode.add(ShaderNode.div(ShaderNode.negate(lightDistance), cutoffDistance), 1)), decayExponent),
    1
  );
});
const V_GGX_SmithCorrelated = new ShaderNode.ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV } = inputs;
  const a2 = ShaderNode.pow2(alpha);
  const gv = ShaderNode.mul(dotNL, ShaderNode.sqrt(ShaderNode.add(a2, ShaderNode.mul(ShaderNode.sub(1, a2), ShaderNode.pow2(dotNV)))));
  const gl = ShaderNode.mul(dotNV, ShaderNode.sqrt(ShaderNode.add(a2, ShaderNode.mul(ShaderNode.sub(1, a2), ShaderNode.pow2(dotNL)))));
  return ShaderNode.div(0.5, ShaderNode.max(ShaderNode.add(gv, gl), ShaderNode.EPSILON));
});
const D_GGX = new ShaderNode.ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = ShaderNode.pow2(alpha);
  const denom = ShaderNode.add(ShaderNode.mul(ShaderNode.pow2(dotNH), ShaderNode.sub(a2, 1)), 1);
  return ShaderNode.mul(1 / Math.PI, ShaderNode.div(a2, ShaderNode.pow2(denom)));
});
const BRDF_GGX = new ShaderNode.ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness } = inputs;
  const alpha = ShaderNode.pow2(roughness);
  const halfDir = ShaderNode.normalize(ShaderNode.add(lightDirection, ShaderNode.positionViewDirection));
  const dotNL = ShaderNode.saturate(ShaderNode.dot(ShaderNode.transformedNormalView, lightDirection));
  const dotNV = ShaderNode.saturate(ShaderNode.dot(ShaderNode.transformedNormalView, ShaderNode.positionViewDirection));
  const dotNH = ShaderNode.saturate(ShaderNode.dot(ShaderNode.transformedNormalView, halfDir));
  const dotVH = ShaderNode.saturate(ShaderNode.dot(ShaderNode.positionViewDirection, halfDir));
  const F = F_Schlick({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
  const D = D_GGX({ alpha, dotNH });
  return ShaderNode.mul(F, ShaderNode.mul(V, D));
});
const RE_Direct_Physical = new ShaderNode.ShaderNode((inputs) => {
  const { lightDirection, lightColor, directDiffuse, directSpecular } = inputs;
  const dotNL = ShaderNode.saturate(ShaderNode.dot(ShaderNode.transformedNormalView, lightDirection));
  let irradiance = ShaderNode.mul(dotNL, lightColor);
  irradiance = ShaderNode.mul(irradiance, Math.PI);
  ShaderNode.addTo(directDiffuse, ShaderNode.mul(irradiance, BRDF_Lambert({ diffuseColor: ShaderNode.diffuseColor.rgb })));
  ShaderNode.addTo(directSpecular, ShaderNode.mul(irradiance, BRDF_GGX({ lightDirection, f0: ShaderNode.specularColor, f90: 1, roughness: ShaderNode.roughness })));
});
const PhysicalLightingModel = new ShaderNode.ShaderNode((inputs) => {
  RE_Direct_Physical(inputs);
});
exports.BRDF_GGX = BRDF_GGX;
exports.BRDF_Lambert = BRDF_Lambert;
exports.D_GGX = D_GGX;
exports.F_Schlick = F_Schlick;
exports.PhysicalLightingModel = PhysicalLightingModel;
exports.RE_Direct_Physical = RE_Direct_Physical;
exports.V_GGX_SmithCorrelated = V_GGX_SmithCorrelated;
exports.getDistanceAttenuation = getDistanceAttenuation;
