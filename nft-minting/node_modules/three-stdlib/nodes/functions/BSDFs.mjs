import { ShaderNode, exp2, mul, sub, add, cond, and, greaterThan, pow, saturate, div, negate, pow2, sqrt, max, EPSILON, normalize, positionViewDirection, dot, transformedNormalView, addTo, diffuseColor, specularColor, roughness } from "../ShaderNode.mjs";
const F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
const BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
const getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  return cond(
    and(greaterThan(cutoffDistance, 0), greaterThan(decayExponent, 0)),
    pow(saturate(add(div(negate(lightDistance), cutoffDistance), 1)), decayExponent),
    1
  );
});
const V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV)))));
  const gl = mul(dotNV, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
const D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
const BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNV = saturate(dot(transformedNormalView, positionViewDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
  const D = D_GGX({ alpha, dotNH });
  return mul(F, mul(V, D));
});
const RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, directDiffuse, directSpecular } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  let irradiance = mul(dotNL, lightColor);
  irradiance = mul(irradiance, Math.PI);
  addTo(directDiffuse, mul(irradiance, BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
  addTo(directSpecular, mul(irradiance, BRDF_GGX({ lightDirection, f0: specularColor, f90: 1, roughness })));
});
const PhysicalLightingModel = new ShaderNode((inputs) => {
  RE_Direct_Physical(inputs);
});
export {
  BRDF_GGX,
  BRDF_Lambert,
  D_GGX,
  F_Schlick,
  PhysicalLightingModel,
  RE_Direct_Physical,
  V_GGX_SmithCorrelated,
  getDistanceAttenuation
};
