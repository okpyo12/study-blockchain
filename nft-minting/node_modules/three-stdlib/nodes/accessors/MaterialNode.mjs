var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import Node from "../core/Node.mjs";
import OperatorNode from "../math/OperatorNode.mjs";
import MaterialReferenceNode from "./MaterialReferenceNode.mjs";
const _MaterialNode = class extends Node {
  constructor(scope = _MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === _MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === _MaterialNode.OPACITY) {
      return "float";
    } else if (scope === _MaterialNode.SPECULAR) {
      return "vec3";
    } else if (scope === _MaterialNode.ROUGHNESS || scope === _MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode("alphaTest", "float");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode("color", "color");
      if (material.map !== null && material.map !== void 0 && material.map.isTexture === true) {
        node = new OperatorNode("*", colorNode, new MaterialReferenceNode("map", "texture"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode("opacity", "float");
      if (material.alphaMap !== null && material.alphaMap !== void 0 && material.alphaMap.isTexture === true) {
        node = new OperatorNode("*", opacityNode, new MaterialReferenceNode("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR) {
      const specularColorNode = new MaterialReferenceNode("specularColor", "color");
      if (material.specularColorMap !== null && material.specularColorMap !== void 0 && material.specularColorMap.isTexture === true) {
        node = new OperatorNode("*", specularColorNode, new MaterialReferenceNode("specularColorMap", "texture"));
      } else {
        node = specularColorNode;
      }
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode(scope, outputType);
    }
    return node.build(builder, output);
  }
};
let MaterialNode = _MaterialNode;
__publicField(MaterialNode, "ALPHA_TEST", "alphaTest");
__publicField(MaterialNode, "COLOR", "color");
__publicField(MaterialNode, "OPACITY", "opacity");
__publicField(MaterialNode, "SPECULAR", "specular");
__publicField(MaterialNode, "ROUGHNESS", "roughness");
__publicField(MaterialNode, "METALNESS", "metalness");
export {
  MaterialNode as default
};
