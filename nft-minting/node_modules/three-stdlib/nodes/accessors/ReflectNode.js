"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const Node = require("../core/Node.js");
const ShaderNode = require("../ShaderNode.js");
const _ReflectNode = class extends Node {
  constructor(scope = _ReflectNode.CUBE) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `reflect-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _ReflectNode.VECTOR) {
      const cameraToFrag = ShaderNode.normalize(ShaderNode.sub(ShaderNode.positionWorld, ShaderNode.cameraPosition));
      const reflectVec = ShaderNode.reflect(cameraToFrag, ShaderNode.normalWorld);
      return reflectVec.build(builder);
    } else if (scope === _ReflectNode.CUBE) {
      const reflectVec = ShaderNode.nodeObject(new _ReflectNode(_ReflectNode.VECTOR));
      const cubeUV = ShaderNode.join(ShaderNode.negate(reflectVec.x), reflectVec.yz);
      return cubeUV.build(builder);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
let ReflectNode = _ReflectNode;
__publicField(ReflectNode, "VECTOR", "vector");
__publicField(ReflectNode, "CUBE", "cube");
module.exports = ReflectNode;
