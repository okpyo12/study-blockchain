"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const Node = require("../core/Node.js");
const ShaderNode = require("../ShaderNode.js");
const THREE = require("three");
const LinearToLinear = new ShaderNode.ShaderNode((inputs) => {
  return inputs.value;
});
const LinearTosRGB = new ShaderNode.ShaderNode((inputs) => {
  const { value } = inputs;
  const rgb = value.rgb;
  const a = ShaderNode.sub(ShaderNode.mul(ShaderNode.pow(value.rgb, ShaderNode.vec3(0.41666)), 1.055), ShaderNode.vec3(0.055));
  const b = ShaderNode.mul(rgb, 12.92);
  const factor = ShaderNode.vec3(ShaderNode.lessThanEqual(rgb, ShaderNode.vec3(31308e-7)));
  const rgbResult = ShaderNode.mix(a, b, factor);
  return ShaderNode.join(rgbResult.r, rgbResult.g, rgbResult.b, value.a);
});
const EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
const _ColorSpaceNode = class extends Node {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === THREE.LinearEncoding) {
      method = "Linear";
    } else if (encoding === THREE.sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const method = this.method;
    const node = this.node;
    if (method !== _ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      return encodingFunctionNode({
        value: node
      }).build(builder, type);
    } else {
      return node.build(builder, type);
    }
  }
};
let ColorSpaceNode = _ColorSpaceNode;
__publicField(ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
__publicField(ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");
exports.LinearToLinear = LinearToLinear;
exports.LinearTosRGB = LinearTosRGB;
exports.default = ColorSpaceNode;
