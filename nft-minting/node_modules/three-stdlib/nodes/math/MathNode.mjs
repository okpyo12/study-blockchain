var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import TempNode from "../core/TempNode.mjs";
import ExpressionNode from "../core/ExpressionNode.mjs";
import JoinNode from "../utils/JoinNode.mjs";
import SplitNode from "../utils/SplitNode.mjs";
import OperatorNode from "./OperatorNode.mjs";
const _MathNode = class extends TempNode {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.getTypeLength(aType);
    const bLen = builder.getTypeLength(bType);
    const cLen = builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === _MathNode.DFDX || method === _MathNode.DFDY) && output === "vec3") {
      return new JoinNode([
        new _MathNode(method, new SplitNode(a, "x")),
        new _MathNode(method, new SplitNode(a, "y")),
        new _MathNode(method, new SplitNode(a, "z"))
      ]).build(builder);
    } else if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode(new OperatorNode("*", tA, tB), "xyz");
      return new _MathNode(_MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === _MathNode.SATURATE) {
      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === _MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(a.build(builder, type), b.build(builder, type));
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, "float"));
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
let MathNode = _MathNode;
__publicField(MathNode, "RAD", "radians");
__publicField(MathNode, "DEG", "degrees");
__publicField(MathNode, "EXP", "exp");
__publicField(MathNode, "EXP2", "exp2");
__publicField(MathNode, "LOG", "log");
__publicField(MathNode, "LOG2", "log2");
__publicField(MathNode, "SQRT", "sqrt");
__publicField(MathNode, "INV_SQRT", "inversesqrt");
__publicField(MathNode, "FLOOR", "floor");
__publicField(MathNode, "CEIL", "ceil");
__publicField(MathNode, "NORMALIZE", "normalize");
__publicField(MathNode, "FRACT", "fract");
__publicField(MathNode, "SIN", "sin");
__publicField(MathNode, "COS", "cos");
__publicField(MathNode, "TAN", "tan");
__publicField(MathNode, "ASIN", "asin");
__publicField(MathNode, "ACOS", "acos");
__publicField(MathNode, "ATAN", "atan");
__publicField(MathNode, "ABS", "abs");
__publicField(MathNode, "SIGN", "sign");
__publicField(MathNode, "LENGTH", "length");
__publicField(MathNode, "NEGATE", "negate");
__publicField(MathNode, "INVERT", "invert");
__publicField(MathNode, "DFDX", "dFdx");
__publicField(MathNode, "DFDY", "dFdy");
__publicField(MathNode, "SATURATE", "saturate");
__publicField(MathNode, "ROUND", "round");
__publicField(MathNode, "MIN", "min");
__publicField(MathNode, "MAX", "max");
__publicField(MathNode, "MOD", "mod");
__publicField(MathNode, "STEP", "step");
__publicField(MathNode, "REFLECT", "reflect");
__publicField(MathNode, "DISTANCE", "distance");
__publicField(MathNode, "DOT", "dot");
__publicField(MathNode, "CROSS", "cross");
__publicField(MathNode, "POW", "pow");
__publicField(MathNode, "TRANSFORM_DIRECTION", "transformDirection");
__publicField(MathNode, "MIX", "mix");
__publicField(MathNode, "CLAMP", "clamp");
__publicField(MathNode, "REFRACT", "refract");
__publicField(MathNode, "SMOOTHSTEP", "smoothstep");
__publicField(MathNode, "FACEFORWARD", "faceforward");
export {
  MathNode as default
};
